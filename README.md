# Node.js的归纳总结

Node是基于事件驱动、非阻塞I/O的服务端开发语言（利用单线程，避开了多线程死锁，状态同步等问题，同时利用异步I/O让单线程远离阻塞，以更好的使用cup，同时为了弥补单线程没办法利用多核CPU的的缺点，node提供了类似浏览器端中web worker的子进程，通过工作进程进而高效利用CPU和I/O）

`需要注意的是这里的单线程指的是JavaScript执行在单线程中的意思，Node自身其实是多线程的，它里面有线程池的概念`

* 模块机制
* 异步I/O以及非I/O的异步API
* 内存控制
* Buffer
* 进程
* 测试

### 模块机制

#### Node主要是遵循CommonJS规范来实现属于自己的模块机制（即通过`exports`、`require`来实现导出、加载模块的方法或变量）

在执行require时大致经历了什么：

* 路径分析
* 文件定位
* 编译执行

在Node中，模块分为两类：核心模块（node提供的）和文件模块（用户自己编写的）

核心模块部分在node源代码编译过程中，编译进了二进制执行文件，即在node进程启动时，部分核心模块会被直接加载进内存中，这就意味着此时是会跳过路径分析和编译执行这两个步骤，且在路径分析中也是优先判断的，所以他的加载速度是最快的

文件模块则是在运行时动态加载，需要注意的是其中的自定义模块（可能是一个文件或者包，且非路劲标识符），这类模块查找是最费时的

`需要注意的是node会优先从缓存加载，核心模块的优先级仅次于缓存加载`

文件定位中会对文件进行文件扩展名分析，在没有写扩展名的情况下会按照.js\.json\.node的次序补足扩展名并以此尝试，需要注意的是在尝试过程中会调用fs模块去判断文件是否存在，这会能会带来性能问题，因为node是单线程的，所以当文件是非js时，建议加上扩展名；

编译执行阶段，对于不同的文件扩展名，node对其的载入也会有所不同：

* .js文件：通过fs模块同步读取文件后编译执行
* .node文件：这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
* .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果
* 其余扩展名文件：会被当做.js文件载入

`编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上`

核心模块分为C/C++编写和JavaScript编写的两部分，前者we年放在node项目的src目录下，后者文件放在lib目录下


### 异步I/O

伴随node的介绍，我们常常听见异步、非阻塞、事件、回调等词语，在听觉角度上看，异步和非阻塞好像是同一回事，其实对于计算机内核而言，I/O只有两种方式：阻塞与非阻塞，阻塞的缺点很明显：会造成cup等待i/o，浪费等待的时间，cup资源得不到充分利用，而非阻塞虽然解决了上诉问题，但同时也带来了新的问题：需要轮询去确认I/O操作是否完成

在启动进程时，Node会创建一个类似while的循环，用来查看是否有事件待处理，每执行一次循环体的过程被称为tick，每个事件循环中都有一个或者多个观察者，而判断是否有事件要处理的过程就是向观察者询问是否有事件要处理的过程。事件循环就是一个典型的观察者/消费者模型，异步I/O、网络请求等就是事件的生产者。

Node是怎么实现异步I/O的，首先要先了解各模块之间都做了什么：一般是先调用Node的核心模块，由核心模块调用C/C++的内建模块，再由内建模块通过libuv进行系统调用，其实这也是Node的经典调用方式。现在再返回来看，当我们在执行读取某个文件时怎么达到异步的效果的：一般JavaScript调用完后会马上返回，然后将后续的操作交给JavaScript线程来执行，也就意味着当前的I/O会在线程池中等待执行，无论它是否阻塞I/O，都不会影响JavaScript线程的往下执行，以此达到异步的目的。

Node里的非I/O的异步操作有：setTimeout()、setInterval()、setImmediate()和process.nextTick()

setTimeout()和setInterval()跟浏览器端的API是一致的