# Node.js的归纳总结

Node是基于事件驱动、非阻塞I/O的服务端开发语言（利用单线程，避开了多线程死锁，状态同步等问题，同时利用异步I/O让单线程远离阻塞，以更好的使用cup，同时为了弥补单线程没办法利用多核CPU的的缺点，node提供了类似浏览器端中web worker的子进程，通过工作进程进而高效利用CPU和I/O）

`需要注意的是这里的单线程指的是JavaScript执行在单线程中的意思，Node自身其实是多线程的，它里面有线程池的概念`

* 模块机制
* 异步I/O以及非I/O的异步API
* 内存控制
* Buffer
* 进程
* 测试

### 模块机制

#### Node主要是遵循CommonJS规范来实现属于自己的模块机制（即通过`exports`、`require`来实现导出、加载模块的方法或变量）

在执行require时大致经历了什么：

* 路径分析
* 文件定位
* 编译执行

在Node中，模块分为两类：核心模块（node提供的）和文件模块（用户自己编写的）

核心模块部分在node源代码编译过程中，编译进了二进制执行文件，即在node进程启动时，部分核心模块会被直接加载进内存中，这就意味着此时是会跳过路径分析和编译执行这两个步骤，且在路径分析中也是优先判断的，所以他的加载速度是最快的

文件模块则是在运行时动态加载，需要注意的是其中的自定义模块（可能是一个文件或者包，且非路劲标识符），这类模块查找是最费时的

`需要注意的是node会优先从缓存加载，核心模块的优先级仅次于缓存加载`

文件定位中会对文件进行文件扩展名分析，在没有写扩展名的情况下会按照.js\.json\.node的次序补足扩展名并以此尝试，需要注意的是在尝试过程中会调用fs模块去判断文件是否存在，这会能会带来性能问题，因为node是单线程的，所以当文件是非js时，建议加上扩展名；

编译执行阶段，对于不同的文件扩展名，node对其的载入也会有所不同：

* .js文件：通过fs模块同步读取文件后编译执行
* .node文件：这是C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
* .json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果
* 其余扩展名文件：会被当做.js文件载入

`编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上`

核心模块分为C/C++编写和JavaScript编写的两部分，前者we年放在node项目的src目录下，后者文件放在lib目录下


### 异步I/O

伴随node的介绍，我们常常听见异步、非阻塞、事件、回调等词语，在听觉角度上看，异步和非阻塞好像是同一回事，其实对于计算机内核而言，I/O只有两种方式：阻塞与非阻塞，阻塞的缺点很明显：会造成cup等待i/o，浪费等待的时间，cup资源得不到充分利用，而非阻塞虽然解决了上诉问题，但同时也带来了新的问题：需要轮询去确认I/O操作是否完成

在启动进程时，Node会创建一个类似while的循环，用来查看是否有事件待处理，每执行一次循环体的过程被称为tick，每个事件循环中都有一个或者多个观察者，而判断是否有事件要处理的过程就是向观察者询问是否有事件要处理的过程。事件循环就是一个典型的观察者/消费者模型，异步I/O、网络请求等就是事件的生产者。

Node是怎么实现异步I/O的，首先要先了解各模块之间都做了什么：一般是先调用Node的核心模块，由核心模块调用C/C++的内建模块，再由内建模块通过libuv进行系统调用，其实这也是Node的经典调用方式。现在再返回来看，当我们在执行读取某个文件时怎么达到异步的效果的：一般JavaScript调用完后会马上返回，然后将后续的操作交给JavaScript线程来执行，也就意味着当前的I/O会在线程池中等待执行，无论它是否阻塞I/O，都不会影响JavaScript线程的往下执行，以此达到异步的目的。

Node里的非I/O的异步操作有：setTimeout()、setInterval()、setImmediate()和process.nextTick()

setTimeout()和setInterval()跟浏览器端的API是一致的，相较于setImmediate()和process.nextTick()，前两者会比较耗性能，因为他们会动用到定时器观察者内部的红黑树，创建定时器对象以及迭代操作等。一般情况下不建议去使用他们。

定时器中采用红黑树的操作时间复杂度为o(lg(n))，process.nextTick()的为o(n)

setImmediate()和process.nextTick()很相似，区别在于process.nextTick()的执行优先级会高于setImmediate()，因为时间循环对观察者的检查是有先后顺序的。process.nextTick()属于idle观察者，setImmediate()属于check观察者，idle观察者优先于I/O观察者，I/O观察者优先于check观察者。

## 内存控制

由于node是基于V8构建的，所以node上的JavaScript对象基本上是通过V8的方式进行管理和分配的（在V8中，所有的JavaScript对象都是通过堆来分配的）

V8限制内存大小的主要原因是垃圾回收机制的限制，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量的垃圾回收甚至要1秒以上，垃圾回收中会暂停JavaScript线程的执行，这样的花销时间，这对于浏览器端和服务器端都是无法接受的，所以直接限制内存是最好的选择。

`可以通过在Node启动时通过传入--max-old-space-size或者--max-new-space-size来获取更多的内存，一旦生效就不能再动态修改了`

在V8中，主要将内存划分为新生代和老生代两代，其中老生代的内存划分会多于新生代内存，新生代中的对象为存活时间较短的对象，而老生代的对象为存活时间较长或者常驻内存的对象。

对象晋升的条件有两个：一个是否经历过scavenge回收，另一个是To空间的内存占比超过了限制

Node对内存泄漏很敏感，在线上有成千上万的流量，即使一个字节的内存泄漏也会造成堆积，使得垃圾回收会花上更多的时间进行扫描对象，应用响应缓慢，直到进程内存溢出，应用奔溃。

一般造成内存泄漏的原因如下：

* 缓存
* 队列消费不及时
* 作用域未被释放

## 进程

由于node是基于V8引擎构建的，所以它的模型与浏览器类似，node的JavaScript也是运行在单个进程的单个线程上，这也就会出现一个问题，对于多核CPU而言，一个Node进程只能利用一个核，这样就会出现无法充分利用cup资源，所以Node引入了子进程来解决这个问题，根据cup的核数来创建子进程去实现多核cup的利用；

可以通过child_process模块创建子进程，他提供了4个方法用于创建子进程：

* spawn()：启动一个子进程来执行命令
* exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。
* execFile()：启动一个子进程来执行可执行文件。
* fork()：与spawn()类似，不同点在于他创建的node的子进程只需要指定要执行的JavaScript文件模块即可。

exec()、execFile()和fork()都是spawn()的延伸。

通过fork()复制的进程都是一个独立而全新的的进程（也是全新的V8实例），它需要至少30毫秒的启动时间和至少10MB的内存，所以fork()进程是昂贵的。

在Master-Worker模式中，父进程和子进程是通过IPC（Inter-Process Communication)通道进行消息传递的，实现进程间通信的技术有： 命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe)技术，这个管道是个抽象层面的称呼。具体实现是根据libuv提供的，在window下有命名管道（named pipe)实现，在*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法。

IPC通道使用命名管道或Domain Socket创建的，它们与网络socket的行为很类似，属于双向通信，不同的是它们在系统内核中就完成了进程间的通信，不经过实际的网络层。

父进程在创建子进程之前，会先创建IPC并监听它，然后才真正的创建出子进程，并通过环境变量（NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符，子进程在启动的过程中，根据文件描述符去连接这个已经存在的IPC通道，从而完成父子进程之间的连接。

搭建集群需要考虑点：

* 性能问题
* 多个工作进程的存活状态管理
* 工作进程的平滑重启
* 配置或者静态数据的动态重新载入
* 其他细节问题



